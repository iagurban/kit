/**
 * Splits an array into smaller sub-arrays (buckets) of a specified size.
 *
 * @template T - The type of elements in the input array.
 * @param {readonly T[]} a - The input array to be divided into buckets.
 * @param {number} size - The maximum size of each bucket (sub-array).
 * @returns {T[][]} An array of sub-arrays, where each sub-array contains elements from the input array.
 *                  The last sub-array may contain fewer elements if the input array cannot be evenly divided.
 */
export const buckets = <T>(a: readonly T[], size: number): T[][] => {
  const r: T[][] = [];
  let offset = 0;
  for (;;) {
    const end = offset + size;
    const n = a.slice(offset, end);
    if (n.length < 1) {
      return r;
    }
    r.push(n);
    offset = end;
  }
};

/**
 * Generates an array of numbers based on the specified length and an optional mapping function.
 *
 * @param {number} length - The number of elements in the resulting array.
 * @param {function(number): number} [by] - An optional function to determine the values of the array.
 *                                          It receives the current index as an argument and returns
 *                                          the value for that index. If not provided, the array will
 *                                          be filled with incremental numbers starting from 0.
 * @returns {number[]} An array of numbers created based on the provided length and optional function.
 */
export const samples = (length: number, by?: (idx: number) => number): number[] =>
  Array.from({ length }, by ? (_, i) => by(i) : (_, i) => i);

/**
 * Generates an array of specified length where each element is determined by a provided callback function.
 *
 * @template T
 * @param {number} length - The length of the resulting array.
 * @param {(index: number) => T} by - A callback function that generates the value of each element in the array.
 *                                    It takes the current index as a parameter and returns the computed value.
 * @returns {T[]} An array populated with values generated by the callback function.
 */
export const samplesBy = <T>(length: number, by: (index: number) => T): T[] =>
  Array.from({ length }, (_, i) => by(i));

/**
 * Selects a specified number of random unique items from a given array.
 *
 * @template T
 * @param {number} count - The number of items to randomly select from the array. Must be a non-negative integer less than or equal to the array's length.
 * @param {readonly T[]} from - The array from which random items will be selected. The input array is not modified.
 * @returns {T[]} An array containing the randomly selected items. No duplicates are included in the resulting array.
 * @throws {Error} Throws an error if the count is negative, not an integer, or exceeds the length of the input array.
 */
export const pickRandomItems = <T>(count: number, from: readonly T[]): T[] => {
  if (count < 0 || count !== Math.trunc(count) || count > from.length) {
    throw new Error('programming error');
  }

  const a = [...from];
  return samplesBy(count, () => a.splice(Math.trunc(Math.random() * a.length), 1)[0]);
};

/**
 * A collection of utility functions for manipulating arrays. Each function allows optional mutation of the original array.
 */
export const ArrayMutators = {
  /**
   * Inserts a value into an array at a specified position.
   * @param a The array to insert into.
   * @param value The value to insert.
   * @param pos The position to insert at.
   * @param mutate Whether to mutate the original array.
   * @returns A new array with the value inserted, or the mutated array.
   */
  insert<T>(a: T[], value: T, pos: number, mutate = false) {
    const copy = mutate ? a : [...a];
    copy.splice(pos, 0, value);
    return copy;
  },
  /**
   * Moves an element within an array from one position to another.
   * @param a The array to move the element in.
   * @param from The position of the element to move.
   * @param to The position to move the element to.
   * @param mutate Whether to mutate the original array.
   * @returns A new array with the element moved, or the mutated array.
   */
  move<T>(a: T[], from: number, to: number, mutate = false) {
    const copy = mutate ? a : [...a];
    copy.splice(to, 0, ...copy.splice(from, 1));
    return copy;
  },
  /**
   * Removes one or more elements from an array.
   * @param a The array to remove elements from.
   * @param from The position to start removing from.
   * @param count The number of elements to remove.
   * @param mutate Whether to mutate the original array.
   * @returns A new array with the elements removed, or the mutated array.
   */
  remove<T>(a: T[], from: number, count = 1, mutate = false) {
    const copy = mutate ? a : [...a];
    copy.splice(from, count);
    return copy;
  },
  /**
   * Sets the value of an element in an array at a specified position.
   * @param a The array to set the element in.
   * @param value The value to set.
   * @param pos The position of the element to set.
   * @param mutate Whether to mutate the original array.
   * @returns A new array with the element set, or the mutated array.
   */
  set<T>(a: T[], value: T, pos: number, mutate = false) {
    const copy = mutate ? a : [...a];
    copy[pos] = value;
    return copy;
  },
};

/**
 * Applies a mapping function to each element of an array if the array is not empty.
 * If the array is empty, a fallback function is executed and its result is returned as an array.
 *
 * @template T The type of elements in the input array.
 * @template U The type of elements in the resulting array.
 * @param {T[]} array The array to be mapped. If it is empty, the fallback function will be used.
 * @param {(t: T, i: number, arr: readonly T[]) => U} mapper The function to apply to each element of the array.
 * @param {() => U} empty A function that is called to provide a default value when the array is empty.
 * @returns {U[]} A new array containing the results of applying the `mapper` function to each element of the array,
 * or an array containing the result of the `empty` function if the array is empty.
 */
export const mapArrayIfNotEmpty = <T, U>(
  array: T[],
  mapper: (t: T, i: number, arr: readonly T[]) => U,
  empty: () => U
): U[] => (array.length === 0 ? [empty()] : array.map(mapper));
