import { isPromise } from '../async/promise-util';
import { AnyAnyFunction } from '../types';

type BusyGuardResult<T extends AnyAnyFunction> =
  ReturnType<T> extends Promise<unknown> ? Promise<ReturnType<T>> : ReturnType<T>;
/**
 * Prevents recursive execution of a given function by ensuring that the function cannot be called again
 * while it is already running. If an attempt is made to call the function recursively, an error will be thrown.
 *
 * @template T - The type of the function to guard against recursion.
 * @param {T} action - The function to guard. This function will only be executed if it is not already in progress.
 * @param {string | ((...args: Parameters<T>) => Error | string)} err - The error to throw if a recursive call is attempted.
 * A static string or a callback function that generates an error or error message based on the arguments of the function.
 * @returns {(args: Parameters<T>) => BusyGuardResult<T>} A wrapped version of the original function that enforces
 * a "no recursion" rule. If the original function returns a promise, the guard ensures that recursion is only allowed
 * after the promise resolves.
 * @throws {Error} If a recursive invocation of the function is attempted, the provided error is thrown.
 */
export const denyRecursion = <T extends AnyAnyFunction>(
  action: T,
  err: string | ((...args: Parameters<T>) => Error | string)
): ((...args: Parameters<T>) => BusyGuardResult<T>) => {
  let busy = false;

  return (...args) => {
    if (busy) {
      if (typeof err === `string`) {
        throw new Error(err);
      }
      const e = err(...args);
      throw typeof e === `string` ? new Error(e) : e;
    }

    busy = true;
    let r: BusyGuardResult<T>;
    try {
      r = action(...args);
    } catch (error) {
      busy = false;
      throw error;
    }

    if (isPromise(r)) {
      return r.finally(() => void (busy = false));
    }

    busy = false;
    return r;
  };
};
const busySymbol: unique symbol = Symbol(`multiRecurringDenier.busy`);
/**
 * A higher-order function that wraps a given function to prevent
 * multiple concurrent invocations with the same key. This utility
 * ensures that only a single operation is in progress for a given
 * key at a time, rejecting new invocations for that key until the
 * current operation completes.
 *
 * @template Fn - The type of the function to be wrapped.
 * @template K - The type of the key derived from the function arguments.
 *
 * @param {Fn} fn - The original function to be wrapped. This function
 *     will be called with the supplied arguments when no other
 *     in-progress call with the same key is detected.
 * @param {(...args: Parameters<Fn>) => K} key - A function that derives
 *     a unique key from the arguments supplied to the wrapped function.
 *     This key will be used to track in-progress and completed calls.
 * @param {(...args: Parameters<Fn>) => string | Error} error - A function
 *     that generates an error message or an error object when an attempt
 *     is made to call the wrapped function concurrently with the same key.
 *     The error message or object will be used in the rejection.
 *
 * @returns {(...args: Parameters<Fn>) => ReturnType<Fn>} A new function
 *     that wraps the given function. When called, this function calculates
 *     the key for the invocation, monitors concurrent executions for the
 *     same key, and prevents redundant invocations. If a conflict occurs,
 *     an error is thrown with the provided error message or object.
 *
 * @throws {Error} Throws an error generated by the `error` parameter if
 *     a duplicate concurrent invocation is detected for a particular key.
 */
export const multiRecurringDenier = <Fn extends AnyAnyFunction, K>(
  fn: Fn,
  key: (...args: Parameters<Fn>) => K,
  error: (...args: Parameters<Fn>) => string | Error
): ((...args: Parameters<Fn>) => ReturnType<Fn>) => {
  const mapping = new Map<K, typeof busySymbol | ReturnType<Fn>>();

  return (...args) => {
    const k = key(...args);

    const ready = mapping.get(k);
    if (ready === busySymbol) {
      const e = error(...args);
      throw typeof e === `string` ? new Error(e) : e;
    }
    if (ready) {
      return ready;
    }
    mapping.set(k, busySymbol);

    try {
      const ret = fn(...args);
      mapping.set(k, ret);
      return ret;
    } catch (error) {
      mapping.delete(k);
      throw error;
    }
  };
};
