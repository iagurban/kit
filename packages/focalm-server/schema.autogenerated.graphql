# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

enum CreatedAtFixReason {
  Both
  High
  Low
}

"""
A date string, such as 2007-12-03, compliant with the `full-date` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar Date

"""
A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format.
"""
scalar DateTime

type IDMapping {
  dst: String!
  src: String!
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON

type Mutation {
  login(login: String!, password: String!): String!
  logout: Boolean!
  updateTasks(changes: [TasksChangesGroup!]!): TasksUpdateResult!
}

type Query {
  tasks(updatedAfter: DateTime): TasksWithRelatedStuff!
}

type RefreshToken {
  createdAt: DateTime!
  expiresAt: DateTime!
  hash: String!
  id: ID!
  user: User!
  userId: String!
}

type StoredFile {
  _count: StoredFileCount!
  createdAt: DateTime!
  hash: String!
  id: ID!
  size: Int!
  uploads: [UploadedFile!]
}

type StoredFileCount {
  uploads: Int!
}

type Task {
  _count: TaskCount!
  archived: Boolean!
  author: User!
  authorId: String!
  children: [Task!]
  createdAt: DateTime!
  dueToDate: Date
  dueToOffset: Int
  ease: Float!
  historyValues: [TaskHistoryValue!]
  id: ID!
  impact: Float!
  orderKey: String!
  parent: Task
  parentId: String
  participants: [UserInTask!]
  plannedStartDate: Date
  plannedStartOffset: Int
  responsible: User
  responsibleId: String
  startAfterDate: Date
  startAfterOffset: Int
  state: TaskState!
  title: String!
  updatedAt: DateTime!
}

type TaskCount {
  children: Int!
  historyValues: Int!
  participants: Int!
}

input TaskFieldUpdateInput {
  field: TaskHistoryKey!
  stringValue: String!
  taskId: String!
}

type TaskHistoryGroup {
  _count: TaskHistoryGroupCount!
  author: User!
  authorId: String!
  createdAt: DateTime!
  createdAtFixReason: CreatedAtFixReason
  id: ID!
  localCreatedAt: DateTime!
  values: [TaskHistoryValue!]
}

type TaskHistoryGroupCount {
  values: Int!
}

enum TaskHistoryKey {
  archived
  authorId
  dueToDate
  dueToOffset
  ease
  impact
  orderKey
  parentId
  participants
  plannedStartDate
  plannedStartOffset
  responsibleId
  startAfterDate
  startAfterOffset
  state
  title
}

enum TaskHistoryOperation {
  Add
  Remove
  Set
}

type TaskHistoryValue {
  group: TaskHistoryGroup!
  groupId: String!
  key: TaskHistoryKey!
  op: TaskHistoryOperation!
  task: Task!
  taskId: String!
  value: JSON!
}

enum TaskState {
  Active
  Done
  Pending
}

input TasksChangesGroup {
  createdAt: DateTime!
  createdAtFixReason: CreatedAtFixReason
  localCreatedAt: DateTime!
  updates: [TaskFieldUpdateInput!]!
}

type TasksUpdateResult {
  changedIds: [IDMapping!]!
  tasks(updatedAfter: DateTime): TasksWithRelatedStuff!
}

type TasksWithRelatedStuff {
  relatedUsers: [User!]!
  tasks: [Task!]!
}

type UploadedFile {
  id: ID!
  mimetype: String!
  originalName: String!
  storedFile: StoredFile!
  storedFileId: String!
  uploadedAt: DateTime!
  uploader: User!
  uploaderId: String!
  url: String!
}

type User {
  _count: UserCount!
  assignedTasks: [Task!]
  authoredTaskChanges: [TaskHistoryGroup!]
  authoredTasks: [Task!]
  createdAt: DateTime!
  email: String!
  id: ID!
  name: String!
  participatingTasks: [UserInTask!]
  passwordHash: String!
  refreshTokens: [RefreshToken!]
  uploadedFiles: [UploadedFile!]
}

type UserCount {
  assignedTasks: Int!
  authoredTaskChanges: Int!
  authoredTasks: Int!
  participatingTasks: Int!
  refreshTokens: Int!
  uploadedFiles: Int!
}

type UserInTask {
  _count: UserInTaskCount!
  id: ID!
  tags: [UserInTaskTag!]
  task: Task!
  taskId: String!
  user: User!
  userId: String!
}

type UserInTaskCount {
  tags: Int!
}

type UserInTaskTag {
  tag: String!
  userInTask: UserInTask!
  userInTaskId: String!
}