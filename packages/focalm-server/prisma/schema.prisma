datasource db {
  url      = env("DATABASE_URL")
  provider = "postgresql"
}

generator oldClient {
  provider      = "prisma-client-js"
  output        = "../src/generated/old-client"
  engineType    = "binary"
  binaryTargets = ["native", "debian-openssl-3.0.x"]
}

generator client {
  provider      = "prisma-client"
  output        = "../src/generated/db-client"
  engineType    = "binary"
  binaryTargets = ["native", "debian-openssl-3.0.x"]
}

generator json {
  provider = "yarn prisma-json-types-generator"
}

generator nestgraphql {
  provider = "prisma-nestjs-graphql"
  output   = "../src/generated/nestgraphql"

  prismaClientImport = "../../db-client"
  purgeOutput        = true

  emitInputBinding = true // ← экспортирует типы ввода
  useInputType     = true // ← делает все non-null поля — non-null в GraphQL
}

// generator nestjsDto {
//   provider = "prisma-generator-nestjs-dto"
//   output   = "../src/generated/nestjs-dto"
//
//   outputToNestJsResourceStructure = "true" // writes dtos and entities to subfolders aligned with NestJS CRUD generator (false)
//   exportRelationModifierClasses   = "true" // Should extra classes generated for relationship field operations on DTOs be exported? (true)
//   reExport                        = "false" // Should an index.ts be created for every folder? (false)
//   createDtoPrefix                 = "Create" // phrase to prefix every CreateDTO class with (Create)
//   updateDtoPrefix                 = "Update" // phrase to prefix every UpdateDTO class with (Update)
//   dtoSuffix                       = "Dto" // phrase to suffix every CreateDTO and UpdateDTO class with (Dto)
//   entityPrefix                    = "" // phrase to prefix every Entity class with (<empty>)
//   entitySuffix                    = "" // phrase to suffix every Entity class with (<empty>)
//   fileNamingStyle                 = "camel" // how to name generated files. Valid choices are "camel", "pascal", "kebab" and "snake". (camel)
// }

// generator erd {
//   provider = "prisma-erd-generator"
//
//   output   = "../prisma/ERD.svg" // svg (default: ./prisma/ERD.svg), png, pdf, md
//   // theme    = "forest" // default, forest, dark, neutral
//   mmdcPath = "./CI"
//
//   // tableOnly = true
//   // ignoreEnums = true
//   includeRelationFromFields = true
//   // disableEmoji = true
//   // puppeteerConfig = "../puppeteerConfig.json"
// }

// generator prismaClassGenerator {
//   provider = "prisma-class-generator"
//
//   output = "../src/generated/classes"
//
//   dryRun                   = false
//   // useSwagger = false
//   // makeIndexFile = false
//   // separateRelationFields = true
//   clientImportPath         = "../db-client"
//   useNonNullableAssertions = false
//   preserveDefaultNullable  = true
// }

// generator joi {
//   provider = "prisma-joi-generator"
//   output   = "../src/generated/joi"
// }

generator zod {
  provider = "prisma-zod-generator"
  output   = "../src/generated/zod"

  isGenerateSelect  = true
  isGenerateInclude = true
}

generator typescriptInterfaces {
  provider = "prisma-generator-typescript-interfaces"

  output      = "../src/generated/interfaces.ts"
  modelType   = "type"
  enumType    = "enum"
  decimalType = "number"
  // optionalNullables = true
  // prettier    = true
}

// generator crudGrahql {
//   provider = "nestjs-prisma-graphql-crud-gen"
//   output   = "../generated/crud"
// }

model User {
  id        String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  createdAt DateTime @default(now())

  email String @unique
  name  String @unique

  passwordHash String @map("externalId")

  uploadedFiles UploadedFile[]

  refreshTokens RefreshToken[]

  assignedTasks       Task[]             @relation("responsible")
  authoredTasks       Task[]             @relation("author")
  authoredTaskChanges TaskHistoryGroup[]
}

model RefreshToken {
  id String @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid

  userId String @db.Uuid
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  expiresAt DateTime

  hash String
}

model StoredFile {
  id String @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid // 'abcdefgh' means path ab/cd/efgh

  hash String
  size Int

  createdAt DateTime @default(now())

  uploads UploadedFile[]

  @@index([hash])
}

model UploadedFile {
  id String @id @default(uuid())

  originalName String
  mimetype     String

  uploadedAt DateTime @default(now())

  uploaderId String @db.Uuid
  uploader   User   @relation(fields: [uploaderId], references: [id])

  storedFileId String     @db.Uuid
  storedFile   StoredFile @relation(fields: [storedFileId], references: [id], onDelete: Restrict)
}

enum TaskState {
  Pending
  Active
  Done
}

enum TaskHistoryKey {
  title
  state
  archived
  impact
  ease
  authorId
  responsibleId
  orderKey
  parentId
}

model TaskHistoryValue {
  groupId String           @db.Uuid
  group   TaskHistoryGroup @relation(fields: [groupId], references: [id], onDelete: Cascade)

  taskId String @db.Uuid // denormalization; equals `this.group.taskId`; remove when prisma can do nested distinct

  key TaskHistoryKey

  value Json

  @@id([groupId, key])
}

enum CreatedAtFixReason {
  Low
  High
  Both
}

model TaskHistoryGroup {
  id String @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid

  taskId String @db.Uuid
  task   Task   @relation(fields: [taskId], references: [id], onDelete: Cascade)

  values TaskHistoryValue[]

  authorId String @db.Uuid
  author   User   @relation(fields: [authorId], references: [id])

  localCreatedAt     DateTime
  createdAt          DateTime // fixed
  createdAtFixReason CreatedAtFixReason?
}

model Task {
  id String @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid

  title    String
  state    TaskState @default(Pending)
  archived Boolean   @default(false)

  impact Float @default(0.5)
  ease   Float @default(0.5)

  startAfter   DateTime?
  plannedStart DateTime?
  dueTo        DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @default(now())

  authorId String @db.Uuid
  author   User   @relation("author", fields: [authorId], references: [id], onDelete: Restrict)

  responsibleId String? @db.Uuid
  responsible   User?   @relation("responsible", fields: [responsibleId], references: [id], onDelete: Restrict)

  parentId String? @db.Uuid
  parent   Task?   @relation("tree", fields: [parentId], references: [id], onDelete: SetNull)
  children Task[]  @relation("tree")
  orderKey String

  historyGroups TaskHistoryGroup[]
}
