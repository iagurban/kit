datasource db {
  url      = env("DATABASE_URL")
  provider = "postgresql"
}

generator oldClient {
  provider        = "prisma-client-js"
  output          = "../src/generated/old-client"
  previewFeatures = ["fullTextSearchPostgres"]
}

generator client {
  provider        = "prisma-client"
  output          = "../src/generated/db-client"
  previewFeatures = ["fullTextSearchPostgres"]
}

generator json {
  provider = "yarn prisma-json-types-generator"
}

generator nestgraphql {
  provider = "prisma-nestjs-graphql"
  output   = "../src/generated/nestgraphql"

  prismaClientImport = "../../db-client"
  purgeOutput        = true

  emitInputBinding = true // ← экспортирует типы ввода
  useInputType     = true // ← делает все non-null поля — non-null в GraphQL

  fields_Scalars_from   = "graphql-scalars"
  fields_Scalars_input  = true
  fields_Scalars_output = true
  fields_Scalars_model  = true
  fields_Scalars_args   = true
}

// generator nestjsDto {
//   provider = "prisma-generator-nestjs-dto"
//   output   = "../src/generated/nestjs-dto"
//
//   outputToNestJsResourceStructure = "true" // writes dtos and entities to subfolders aligned with NestJS CRUD generator (false)
//   exportRelationModifierClasses   = "true" // Should extra classes generated for relationship field operations on DTOs be exported? (true)
//   reExport                        = "false" // Should an index.ts be created for every folder? (false)
//   createDtoPrefix                 = "Create" // phrase to prefix every CreateDTO class with (Create)
//   updateDtoPrefix                 = "Update" // phrase to prefix every UpdateDTO class with (Update)
//   dtoSuffix                       = "Dto" // phrase to suffix every CreateDTO and UpdateDTO class with (Dto)
//   entityPrefix                    = "" // phrase to prefix every Entity class with (<empty>)
//   entitySuffix                    = "" // phrase to suffix every Entity class with (<empty>)
//   fileNamingStyle                 = "camel" // how to name generated files. Valid choices are "camel", "pascal", "kebab" and "snake". (camel)
// }

// generator erd {
//   provider = "prisma-erd-generator"
//
//   output   = "../prisma/ERD.svg" // svg (default: ./prisma/ERD.svg), png, pdf, md
//   // theme    = "forest" // default, forest, dark, neutral
//   mmdcPath = "./CI"
//
//   // tableOnly = true
//   // ignoreEnums = true
//   includeRelationFromFields = true
//   // disableEmoji = true
//   // puppeteerConfig = "../puppeteerConfig.json"
// }

// generator prismaClassGenerator {
//   provider = "prisma-class-generator"
//
//   output = "../src/generated/classes"
//
//   dryRun                   = false
//   // useSwagger = false
//   // makeIndexFile = false
//   // separateRelationFields = true
//   clientImportPath         = "../db-client"
//   useNonNullableAssertions = false
//   preserveDefaultNullable  = true
// }

// generator joi {
//   provider = "prisma-joi-generator"
//   output   = "../src/generated/joi"
// }

generator zod {
  provider = "prisma-zod-generator"
  output   = "../src/generated/zod"

  isGenerateSelect  = true
  isGenerateInclude = true
}

generator typescriptInterfaces {
  provider = "prisma-generator-typescript-interfaces"

  output      = "../src/generated/interfaces.ts"
  modelType   = "type"
  enumType    = "enum"
  decimalType = "number"
  // optionalNullables = true
  // prettier    = true
}

// generator crudGrahql {
//   provider = "nestjs-prisma-graphql-crud-gen"
//   output   = "../generated/crud"
// }

model User {
  id        String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  createdAt DateTime @default(now())

  email  String  @unique
  name   String  @unique
  abbrev String?

  passwordHash String @map("externalId")

  uploadedFiles UploadedFile[]

  refreshTokens RefreshToken[]

  assignedTasks       Task[]             @relation("responsible")
  authoredTasks       Task[]             @relation("author")
  authoredTaskChanges TaskHistoryGroup[]

  participatingTasks UserInTask[] @relation("user")

  ownProjectId String  @unique @db.Uuid
  ownProject   Project @relation("own", fields: [ownProjectId], references: [id], onDelete: Restrict)

  inProjects UserInProject[]
}

model RefreshToken {
  id String @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid

  userId String @db.Uuid
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  expiresAt DateTime

  hash String
}

model StoredFile {
  id String @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid // 'abcdefgh' means path ab/cd/efgh

  hash String
  size Int

  createdAt DateTime @default(now())

  uploads UploadedFile[]

  @@index([hash])
}

model UploadedFile {
  id String @id @default(uuid())

  originalName String
  mimetype     String

  uploadedAt DateTime @default(now())

  uploaderId String @db.Uuid
  uploader   User   @relation(fields: [uploaderId], references: [id])

  storedFileId String     @db.Uuid
  storedFile   StoredFile @relation(fields: [storedFileId], references: [id], onDelete: Restrict)
}

enum TaskState {
  Pending
  Active
  Done
}

enum TaskHistoryOperation {
  Set
  Add
  Remove
}

enum TaskHistoryKey {
  title
  state
  archived
  impact
  ease
  authorId
  responsibleId
  participants
  relations
  orderKey
  parentId
  projectId
  description

  startAfterDate
  startAfterOffset
  plannedStartDate
  plannedStartOffset
  dueToDate
  dueToOffset
}

model TaskHistoryValue {
  id String @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid

  groupId String           @db.Uuid
  group   TaskHistoryGroup @relation(fields: [groupId], references: [id], onDelete: Cascade)

  taskId String @db.Uuid
  task   Task   @relation(fields: [taskId], references: [id], onDelete: Cascade)

  key TaskHistoryKey
  op  TaskHistoryOperation @default(Set)

  value Json
}

enum CreatedAtFixReason {
  Low
  High
  Both
}

model TaskHistoryGroup {
  id String @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid

  values TaskHistoryValue[]

  authorId String @db.Uuid
  author   User   @relation(fields: [authorId], references: [id])

  localCreatedAt     DateTime
  createdAt          DateTime // fixed
  createdAtFixReason CreatedAtFixReason?
}

model Project {
  id String @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid

  ownOf User? @relation("own")

  tasksCounter BigInt  @default(0)
  name         String
  abbrev       String?

  relationTypes TaskToTaskRelationType[]
  tasks         Task[]

  usersPermissions UserInProject[]
}

model Task {
  id String @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid

  title    String
  state    TaskState @default(Pending)
  archived Boolean   @default(false)

  impact Float @default(0.5)
  ease   Float @default(0.5)

  /// @FieldType('Scalars.GraphQLDate')
  startAfterDate     DateTime? @db.Date
  startAfterOffset   Int? // секунды от начала дня, NULL → all-day
  /// @FieldType('Scalars.GraphQLDate')
  plannedStartDate   DateTime? @db.Date
  plannedStartOffset Int? // секунды от начала дня, NULL → all-day
  /// @FieldType('Scalars.GraphQLDate')
  dueToDate          DateTime? @db.Date
  dueToOffset        Int? // секунды от начала дня, NULL → all-day

  createdAt DateTime @default(now())
  updatedAt DateTime @default(now())

  authorId String @db.Uuid
  author   User   @relation("author", fields: [authorId], references: [id], onDelete: Restrict)

  responsibleId String? @db.Uuid
  responsible   User?   @relation("responsible", fields: [responsibleId], references: [id], onDelete: Restrict)

  parentId    String? @db.Uuid
  parent      Task?   @relation("tree", fields: [parentId], references: [id], onDelete: SetNull)
  children    Task[]  @relation("tree")
  description Json    @default("{\"type\":\"doc\"}")
  orderKey    String

  participants  UserInTask[]       @relation("task")
  historyValues TaskHistoryValue[]

  relationsSrc TaskToTaskRelation[] @relation("src")
  relationsDst TaskToTaskRelation[] @relation("dst")

  projectId   String  @db.Uuid
  project     Project @relation(fields: [projectId], references: [id], onDelete: Cascade)
  nnInProject BigInt
}

model UserInTask {
  id String @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid

  userId String @db.Uuid
  user   User   @relation("user", fields: [userId], references: [id], onDelete: Cascade)

  taskId String @db.Uuid
  task   Task   @relation("task", fields: [taskId], references: [id], onDelete: Cascade)

  tags UserInTaskTag[]
}

model ParticipantRole {
  id String @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid

  name  String
  color String

  usersInTasks UserInTaskTag[]
}

model UserInTaskTag {
  userInTaskId String     @db.Uuid
  userInTask   UserInTask @relation(fields: [userInTaskId], references: [id], onDelete: Cascade)

  roleId String          @db.Uuid
  role   ParticipantRole @relation(fields: [roleId], references: [id], onDelete: Cascade)

  @@id([userInTaskId, roleId])
}

model TaskToTaskRelationType {
  id String @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid

  forward String
  inverse String

  relations TaskToTaskRelation[]

  projectId String  @db.Uuid
  project   Project @relation(fields: [projectId], references: [id], onDelete: Cascade)
}

model TaskToTaskRelation {
  srcId String @db.Uuid
  src   Task   @relation("src", fields: [srcId], references: [id], onDelete: Cascade)

  dstId String @db.Uuid
  dst   Task   @relation("dst", fields: [dstId], references: [id], onDelete: Cascade)

  typeId String                 @db.Uuid
  type   TaskToTaskRelationType @relation(fields: [typeId], references: [id], onDelete: Cascade)

  @@id([srcId, dstId, typeId])
}

enum PermissionKind {
  read
  update
  create
  delete
}

enum PermissionInProject {
  tasks
  participants
}

model UserInProject {
  userId String @db.Uuid
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  projectId String  @db.Uuid
  project   Project @relation(fields: [projectId], references: [id], onDelete: Cascade)

  permission PermissionInProject
  kind       PermissionKind

  @@id([userId, projectId, permission, kind])
}
