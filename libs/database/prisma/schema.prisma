datasource db {
  url      = env("DATABASE_URL")
  provider = "postgresql"
}

// generator oldClient {
//   provider        = "prisma-client-js"
//   output          = "../src/generated/old-client"
//   previewFeatures = ["fullTextSearchPostgres"]
// }

generator client {
  provider        = "prisma-client"
  output          = "../src/generated/db-client"
  previewFeatures = ["fullTextSearchPostgres"]
}

generator json {
  provider = "yarn prisma-json-types-generator"
}

generator nestgraphql {
  provider = "yarn prisma-nestjs-graphql"
  output   = "../src/generated/nestgraphql"

  prismaClientImport = "../../db-client"
  purgeOutput        = true

  emitInputBinding = true // ← экспортирует типы ввода
  useInputType     = true // ← делает все non-null поля — non-null в GraphQL

  fields_Scalars_from   = "graphql-scalars"
  fields_Scalars_input  = true
  fields_Scalars_output = true
  fields_Scalars_model  = true
  fields_Scalars_args   = true
}

// generator erd {
//   provider = "prisma-erd-generator"
//
//   output   = "../prisma/ERD.svg" // svg (default: ./prisma/ERD.svg), png, pdf, md
//   // theme    = "forest" // default, forest, dark, neutral
//   mmdcPath = "./CI"
//
//   // tableOnly = true
//   // ignoreEnums = true
//   includeRelationFromFields = true
//   // disableEmoji = true
//   // puppeteerConfig = "../puppeteerConfig.json"
// }

// generator zod {
//   provider = "yarn prisma-zod-generator"
//   output   = "../src/generated/zod"
//
//   isGenerateSelect  = true
//   isGenerateInclude = true
// }

generator typescriptInterfaces {
  provider = "yarn prisma-generator-typescript-interfaces"

  output      = "../src/generated/interfaces.ts"
  modelType   = "type"
  enumType    = "enum"
  decimalType = "number"
  // optionalNullables = true
  // prettier    = true
}

// generator crudGrahql {
//   provider = "nestjs-prisma-graphql-crud-gen"
//   output   = "../generated/crud"
// }

model User {
  id        String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  createdAt DateTime @default(now())

  email  String  @unique
  name   String  @unique
  abbrev String?

  // passwordHash String @map("externalId")

  uploadedFiles StoredFile[]

  // refreshTokens RefreshToken[]

  chatEvents ChatEvent[]

  chatsPermissions UserChatPermissions[]
  chatsMmbership   ChatMember[]
  ownChats         Chat[]
  RefreshToken     RefreshToken[]
}

model RefreshToken {
  id String @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid

  userId String @db.Uuid
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  expiresAt DateTime

  hash String
}

// This enum now describes the state of the upload process itself.
enum UploadStatus {
  ACTIVE
  FINALIZING
  FAILED
}

model StoredFile {
  id               String   @id @default(uuid()) @db.Uuid
  // status         FileStatus @default(UPLOADING) // THIS LINE IS REMOVED
  checksum         String
  sizeBytes        BigInt
  originalFilename String
  mimeType         String
  storageKey       String   @unique
  cdnUrl           String
  metadata         Json?
  uploadedByUserId String   @db.Uuid
  uploadedByUser   User     @relation(fields: [uploadedByUserId], references: [id], onDelete: Restrict)
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  // The status is now implicitly defined by this relation.
  uploadSession UploadSession?

  @@unique([checksum, sizeBytes])
  @@index([uploadedByUserId])
}

model UploadSession {
  id              String     @id @default(uuid()) @db.Uuid
  storageUploadId String     @unique
  fileId          String     @unique @db.Uuid
  file            StoredFile @relation(fields: [fileId], references: [id], onDelete: Cascade)
  totalChunks     Int

  // Status of the upload process. THIS is the source of truth.
  status            UploadStatus @default(ACTIVE)
  failReason        String?
  totalFailureCount Int          @default(0)

  chunks    UploadChunk[]
  createdAt DateTime      @default(now())
}

// This table tracks the status of each individual chunk.
model UploadChunk {
  id        String        @id @default(uuid()) @db.Uuid
  sessionId String        @db.Uuid
  session   UploadSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  // The part number (1, 2, 3, ...).
  partNumber Int

  // The ETag returned by S3 after a successful chunk upload.
  // It's nullable because initially the chunk is not uploaded.
  eTag String?

  leasedAt DateTime? // when last user took for job

  // Composite unique key to prevent duplicate records for the same chunk.
  @@unique([sessionId, partNumber])
}

model Chat {
  id String @id @default(uuid()) @db.Uuid

  title  String
  bio    String?
  avatar String?

  ownerId String @db.Uuid
  owner   User   @relation(fields: [ownerId], references: [id])

  events          ChatEvent[]
  eventsCounter   ChatEventsCounter? // it MUST exist at business logic
  messagesCounter MessagesCounter? // it MUST exist at business logic

  defaultRoleId String?   @db.Uuid
  defaultRole   ChatRole? @relation("defaultRoleForChat", fields: [defaultRoleId], references: [id])

  userPermissions UserChatPermissions[]
  roles           ChatRole[]
  members         ChatMember[]
}

model ChatEventsCounter {
  chatId String @id @db.Uuid
  chat   Chat   @relation(fields: [chatId], references: [id], onDelete: Cascade)

  lastNn BigInt @default(0)
}

model MessagesCounter {
  chatId String @id @db.Uuid
  chat   Chat   @relation(fields: [chatId], references: [id], onDelete: Cascade)

  lastNn BigInt @default(0)
}

model ChatEvent {
  id BigInt @id @default(autoincrement())

  // Локальный, бизнес-ID события внутри чата
  nn BigInt

  chatId String @db.Uuid
  chat   Chat   @relation(fields: [chatId], references: [id], onDelete: Cascade)

  authorId String @db.Uuid
  author   User   @relation(fields: [authorId], references: [id], onDelete: Cascade)

  // Денормализованный тип события для быстрой фильтрации
  type String // "message", "info", "user_added", etc.

  // Типизированный JSONB payload
  payload Json

  createdAt DateTime

  @@unique([chatId, nn])
  @@index([authorId, chatId])
}

enum ChatRoleTag {
  ADMIN
  MODERATOR
  MEMBER
  VIEWER
  BANNED
}

model ChatRole {
  id     String @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  chatId String @db.Uuid
  chat   Chat   @relation(fields: [chatId], references: [id], onDelete: Cascade)

  name String
  tags ChatRoleTag[]

  isDefaultForChats Chat[] @relation("defaultRoleForChat")

  permissions Json @db.JsonB

  // This relation is to the permissions table, not ChatMember
  userPermissions UserChatPermissions[]

  @@unique([chatId, name])
}

model UserChatPermissions {
  userId String @db.Uuid
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  chatId String @db.Uuid
  chat   Chat   @relation(fields: [chatId], references: [id], onDelete: Cascade)

  roleId String?   @db.Uuid
  role   ChatRole? @relation(fields: [roleId], references: [id], onDelete: SetNull)

  permissions Json? @db.JsonB // The field is optional and can be null.

  @@id([userId, chatId])
}

model ChatMember {
  userId String @db.Uuid
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  chatId String @db.Uuid
  chat   Chat   @relation(fields: [chatId], references: [id], onDelete: Cascade)

  // Timestamp for when the user joined the chat.
  joinedAt DateTime @default(now())

  @@id([userId, chatId])
}
